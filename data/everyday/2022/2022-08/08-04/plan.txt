==============================
2022-8-4  Thu.     PLAN 
==============================

00:58-01:03       5 mins
P1. 在leecode中快速实现下堆排序。

01:03-01:19      16 mins ---------- free ----------
01:19-01:49      30 mins
P2. read the DCGAN's code in the 30 minutes. 

01:49-08:39     410 mins ---------- free ----------
08:39-08:49      10 mins
P3. 10 minutes typeracers.

08:49-08:54       5 mins ---------- free ----------
08:54-09:09      15 mins
P4. 优化main.py加入一个选项，只使用plan，没有question和record。全部都是放在plan中。完成之后也是打开plan。

09:09-09:09       0 mins ---------- free ----------
09:09-09:14       5 mins
P5. test the new program. that is the ok. thing! Good job guy!

09:14-09:18       4 mins ---------- free ----------
09:18-09:23       5 mins
P6. 优化一下free中的时间显示问题，如果分钟数大于60的话，就使用小时来表示。
-> ok. 加一个条件就可以了。 如果时间大于60的话，就使用小时来表示。

09:23-09:28       5 mins ---------- free ----------
09:28-09:43      15 mins
P7. 15 分钟手撕一下conv的函数实现。一定要拿下来。
-> 完成。测试通过。有一点要注意的就是，创建fm out的时候，它的通道数是取决于卷积核的数量，在这里的话，我们使用的是一个卷积核的代码，所以，输出的卷积应该就是只有一层，所以就是一个二维的矩阵而已。

09:43-11:10     1.4 hours ---------- free ----------
11:10-11:30      20 mins
P8. 继续看完GCGAN的代码。加油。
-> 基本上搞掂了。可以的。知道大概的训练流程了。

11:30-14:51     3.4 hours ---------- free ----------
14:51-15:01      10 mins
P9. 10 minutes typing! 8 races, and the result is the 65WPM. 

15:01-15:08      7 mins  ---------- free ----------
15:08-15:13       5 mins
P10. 5 minute ace the heap sort. 4min 10 second, ok!

15:13-15:28     15 mins  ---------- free ----------
15:28-15:48      20 mins
P11. Transpose conv 的计算方式。计算思路，写一下。比较一下和conv有什么区别？用在哪里？
-> question：仔细看了一下计算的公式，其中会用到卷积的时候的stride作为填充，这个不是很理解啊。

15:48-15:59     11 mins  ---------- free ----------
15:59-16:29      30 mins
P12. 关于买卖股票的问题：1）买入一次； 2） 买入两次；3）买入k次； 第一种情况花5分钟快速搞掂；后面两种情况，重新理一下。
->完成了：1）只能进行一次交易的情况； 2）可以进行无数次交易的情况； 3）只可以进行两次交易的情况；
-》明白了初始化的方法。就是一天之内可以进行多次的买卖；
-》还没有完成：1）只可以进行k次交易的情况；2）有冷冻期；3）需要交手续费。 所以总共就是6种情况。

16:29-16:49     20 mins  ---------- free ----------
16:49-17:04      15 mins
P13. 总结一下关于链表的排序，并且完成至少一道题目。
-》其实就是一道题目，对于链表排序，有一个通用的方法就是，就是将链表的地址存放在一个vector中，然后，比较的时候，比较的是链表中的值，然后移动的是链表的地址。最后将vector中的所有的node连接成一个就可以了。
-》但是上面的方法的空间的复杂度是0（n）。如果使用归并排序的话，可以做到logn，但是如果是使用自底向定的归并排序，可以做到常数空间。
-》所以，这题的关键方法：
1）自底向上的归并排序
2）自顶向下的归并排序。 

17:04-18:50     1.8 hours ---------- free ----------
18:50-19:10      20 mins
P14. 使用两种方法写好链表的排序：1）基于将node存放在vector的归并的方法；2）直接是基于链表的方法。
-> 并没有写出来。

19:10-19:37     27 mins  ---------- free ----------
19:37-19:42       5 mins
P15. 5 minutes, 写好数组的归并排序。
-> 没有写好，不知道是哪一步出错了，仔细检查一下。这个完全和链表那里的思路写的一样。

19:42-20:30     48 mins  ---------- free ----------
20:30-21:15      45 mins
P16. 把反卷积的那个文档看了。就是英文原文的那个文档。大概就是6 7 页的样子，可以看完的。
-》看了一大部分，总算是有一些理解了。本质上就是连接关系要对应上，这个对应上就好了。这个非常重要。
-》还要分情况：1）no padding 2） with padding， s=1； 2）no padding， s>1; 4)padding, s
>1.